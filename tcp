#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""TCP related tools
============================

This script will handle various instrumentation related to Linux TCP
stack. It is heavily inspired from agentzh script:
https://github.com/agentzh/nginx-systemtap-toolkit/blob/master/tcp-accept-queue

"""

import sys
import os
import stap
import jinja2


@stap.d.enable
@stap.d.linux("3.11")
@stap.d.arg("port", metavar="PORT", type=int,
            help="listening port to be analyzed")
@stap.d.arg("--interval", default=1000, type=int,
            help="delay between screen updates in milliseconds")
def accept_queue_length(options):
    """Distribution of SYN and accept queue length."""
    probe = jinja2.Template(ur"""
global syn_qlen_stats
global acc_qlen_stats
global max_syn_qlen
global max_acc_qlen

probe kernel.function("tcp_v4_conn_request") {
    tcphdr = __get_skb_tcphdr($skb);
    dport = __tcp_skb_dport(tcphdr);
    if (dport != {{ options.port }}) next;

    // First time: compute maximum queue lengths
    if (max_syn_qlen == 0) {
      max_qlen_log = @cast($sk,
         "struct inet_connection_sock")->icsk_accept_queue->listen_opt->max_qlen_log;
      max_syn_qlen = (1 << max_qlen_log);
    }
    if (max_acc_qlen == 0) {
      max_acc_qlen = $sk->sk_max_ack_backlog;
    }

    syn_qlen = @cast($sk, "struct inet_connection_sock")->icsk_accept_queue->listen_opt->qlen;
    syn_qlen_stats <<< syn_qlen;

    acc_qlen_stats <<< $sk->sk_ack_backlog;
}

probe timer.ms({{ options.interval }}) {
    if (max_syn_qlen == 0) {
      printf("No new connection on port {{ options.port }}, yet.\n");
      next;
    }
    ansi_clear_screen();
    ansi_set_color2(30, 46);
    printf(" ♦ Syn queue \n");
    ansi_reset_color();
    print(@hist_log(syn_qlen_stats))
    printf(" — min:%d avg:%d max:%d count:%d\n",
                     @min(syn_qlen_stats),
                     @avg(syn_qlen_stats),
                     @max(syn_qlen_stats),
                     @count(syn_qlen_stats));
    printf(" — allowed maximum: %d\n\n", max_syn_qlen);

    ansi_set_color2(30, 46);
    printf(" ♦ Accept queue \n");
    ansi_reset_color();
    print(@hist_log(acc_qlen_stats))
    printf(" — min:%d avg:%d max:%d count:%d\n",
                     @min(acc_qlen_stats),
                     @avg(acc_qlen_stats),
                     @max(acc_qlen_stats),
                     @count(acc_qlen_stats));
    printf(" — allowed maximum: %d\n\n", max_acc_qlen);
}
""")
    probe = probe.render(options=options).encode("utf-8")
    stap.execute(probe, options)


@stap.d.enable
@stap.d.linux("3.11")
@stap.d.arg("port", metavar="PORT", type=int,
            help="listening port to be analyzed")
@stap.d.arg("--interval", default=1000, type=int,
            help="delay between screen updates in milliseconds")
def accept_queue_latency(options):
    """Distribution of accept queue latencies."""
    probe = jinja2.Template(ur"""
global begin_times;
global latency_stats;
global found;

probe kernel.function("tcp_openreq_init") {
    tcphdr = __get_skb_tcphdr($skb);
    dport = __tcp_skb_dport(tcphdr);
    if (dport != {{ options.port }}) next;

    begin_times[$req] = gettimeofday_us();
{%- if options.debug %}
    printf("%s: %p %d\n", ppfunc(), $req, dport);
{%- endif %}
}

probe kernel.function("inet_csk_accept"),
  kernel.function("inet_csk_wait_for_connect").return {
    req = @cast($sk, "struct inet_connection_sock")->icsk_accept_queue->rskq_accept_head;
    begin = begin_times[req];
    if (!begin) next;

    elapsed = gettimeofday_us() - begin;
{%- if options.debug %}
    printf("%s: sk=%p, req=%p, latency=%d\n", ppfunc(), $sk, req, elapsed);
{%- endif %}
    latency_stats <<< elapsed;
    delete begin_times[req];
    found = 1;
}

probe timer.ms({{ options.interval }}) {
    if (found == 0) {
      printf("No new connection on port {{ options.port }}, yet.\n");
      next;
    }
    ansi_clear_screen();
    ansi_set_color2(30, 46);
    printf(" ♦ Accept queueing latency distribution \n");
    ansi_reset_color();
    print(@hist_log(latency_stats))
    printf(" — min:%dus avg:%dus max:%dus count:%d\n",
                     @min(latency_stats),
                     @avg(latency_stats),
                     @max(latency_stats),
                     @count(latency_stats));
}
""")
    probe = probe.render(options=options).encode("utf-8")
    stap.execute(probe, options)


@stap.d.enable
@stap.d.linux("3.11")
@stap.d.arg("port", metavar="PORT", type=int,
            help="listening port to be analyzed")
def accept_queue_overflow(options):
    """Trace SYN/ACK backlog queue overflows"""
    probe = jinja2.Template(ur"""
probe kernel.function("tcp_v4_conn_request") {
    tcphdr = __get_skb_tcphdr($skb);
    dport = __tcp_skb_dport(tcphdr);
    if (dport != {{ options.port }}) next;

    syn_qlen = @cast($sk, "struct inet_connection_sock")->icsk_accept_queue->listen_opt->qlen;
    max_syn_qlen_log = @cast($sk, "struct inet_connection_sock")->icsk_accept_queue->listen_opt->max_qlen_log;
    max_syn_qlen = (2 << max_syn_qlen_log);

    if (syn_qlen > max_syn_qlen) {
            now = tz_ctime(gettimeofday_s());
            printf("[%s] SYN queue is overflown: %d > %d\n", now, syn_qlen, max_syn_qlen);
    }

    ack_backlog = $sk->sk_ack_backlog;
    max_ack_backlog = $sk->sk_max_ack_backlog;

    if (ack_backlog > max_ack_backlog) {
            now = tz_ctime(gettimeofday_s());
            printf("[%s] ACK backlog queue is overflown: %d > %d\n", now, ack_backlog, max_ack_backlog);
    }
}
""")
    probe = probe.render(options=options).encode("utf-8")
    stap.execute(probe, options)


@stap.d.enable
@stap.d.linux("4.0.0")
@stap.d.arg("--sport", metavar="SPORT", type=int,
            default=0,
            help="filter source port")
@stap.d.arg("--dport", metavar="DPORT", type=int,
            default=0,
            help="filter destination port")
@stap.d.arg("--interval", metavar="MS", default=1000, type=int,
            help="delay between screen updates in milliseconds")
@stap.d.arg("--step", metavar="SIZE", type=int,
            default=200,
            help="each bucket represent SIZE kbytes")
def receive_window_size(options):
    """Display receive window size advertised for the specified connection"""
    # We could watch for tcp_select_window return value but this
    # function is inlined. We prefer tcp_option_write which is
    # happening a bit later.
    probe = jinja2.Template(ur"""
global window_sizes;
global found;

probe kernel.function("tcp_options_write").return {
    tcphdrptr = $ptr - &@cast(0, "tcphdr")[1];
    sport = ntohs(@cast(tcphdrptr, "tcphdr")->source);
{%- if options.sport != 0 %}
    if ({{options.sport}} != sport) next;
{%- endif %}
    dport = ntohs(@cast(tcphdrptr, "tcphdr")->dest);
{%- if options.dport != 0 %}
    if ({{options.dport}} != dport) next;
{%- endif %}
    scaled_window = ntohs(@cast(tcphdrptr, "tcphdr")->window);
    scale_factor = $tp->rx_opt->rcv_wscale
    window = scaled_window << scale_factor;
    window_sizes <<< window/1024;
    found = 1;
{%- if options.debug %}
    printf("[%d -> %d]: window size=%d\n", sport, dport, window);
{%- endif %}
}

probe timer.ms({{ options.interval }}) {
    if (found == 0) {
      printf("No window sizes captured, yet.\n");
      next;
    }
    ansi_clear_screen();
    ansi_set_color2(30, 46);
    printf(" ♦ Window size distribution \n");
    ansi_reset_color();
    print(@hist_linear(window_sizes, 0, {{ options.step * 20 }}, {{ options.step }}))
    printf(" — min:%dkb avg:%dkb max:%dkb count:%d\n",
                     @min(window_sizes),
                     @avg(window_sizes),
                     @max(window_sizes),
                     @count(window_sizes));
}
""")
    probe = probe.render(options=options).encode("utf-8")
    stap.execute(probe, options)


stap.run(sys.modules[__name__])
